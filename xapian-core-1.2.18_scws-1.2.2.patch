diff --git a/xapian-core-1.2.18/api/omqueryinternal.cc b/xapian-core-1.2.18/api/omqueryinternal.cc
index 27c916d..eabbe73 100644
--- a/xapian-core-1.2.18/api/omqueryinternal.cc
+++ b/xapian-core-1.2.18/api/omqueryinternal.cc
@@ -370,6 +370,11 @@ Xapian::Query::Internal::accumulate_terms(
 	// Not a leaf, concatenate results from all subqueries.
 	for (subquery_list::const_iterator i = subqs.begin(); i != end; ++i) {
 	    (*i)->accumulate_terms(terms);
+#ifdef HAVE_SCWS
+        // hightman: strip unused term for highlight/reform query log
+        if (op == OP_AND_MAYBE || op == OP_AND_NOT)
+        break;
+#endif
 	}
     }
 }
diff --git a/xapian-core-1.2.18/config.h.in b/xapian-core-1.2.18/config.h.in
index 31eda36..d01731b 100644
--- a/xapian-core-1.2.18/config.h.in
+++ b/xapian-core-1.2.18/config.h.in
@@ -57,6 +57,9 @@
 /* Define if pwrite is available on this system */
 #undef HAVE_PWRITE
 
+/* Define to 1 if you want to use scws as default tokenizer */
+#undef HAVE_SCWS
+
 /* Define to 1 if you have the `random' function. */
 #undef HAVE_RANDOM
 
diff --git a/xapian-core-1.2.18/configure b/xapian-core-1.2.18/configure
index 668ea8a..022d485 100755
--- a/xapian-core-1.2.18/configure
+++ b/xapian-core-1.2.18/configure
@@ -1,6 +1,6 @@
 #! /bin/sh
 # Guess values for system-dependent variables and create Makefiles.
-# Generated by GNU Autoconf 2.68 for xapian-core 1.2.18.
+# Generated by GNU Autoconf 2.68 for xapian-core-scws 1.2.18.
 #
 # Report bugs to <http://xapian.org/bugs>.
 #
@@ -568,10 +568,10 @@ MFLAGS=
 MAKEFLAGS=
 
 # Identity of this package.
-PACKAGE_NAME='xapian-core'
-PACKAGE_TARNAME='xapian-core'
+PACKAGE_NAME='xapian-core-scws'
+PACKAGE_TARNAME='xapian-core-scws'
 PACKAGE_VERSION='1.2.18'
-PACKAGE_STRING='xapian-core 1.2.18'
+PACKAGE_STRING='xapian-core-scws 1.2.18'
 PACKAGE_BUGREPORT='http://xapian.org/bugs'
 PACKAGE_URL=''
 
@@ -804,6 +804,7 @@ enable_quiet
 enable_visibility
 enable_assertions
 enable_log
+with_scws
 enable_largefile
 '
       ac_precious_vars='build_alias
@@ -1362,7 +1363,7 @@ if test "$ac_init_help" = "long"; then
   # Omit some internal or obsolete options to make the list less imposing.
   # This message is too long to be a string in the A/UX 3.1 sh.
   cat <<_ACEOF
-\`configure' configures xapian-core 1.2.18 to adapt to many kinds of systems.
+\`configure' configures xapian-core-scws 1.2.18 to adapt to many kinds of systems.
 
 Usage: $0 [OPTION]... [VAR=VALUE]...
 
@@ -1410,7 +1411,7 @@ Fine tuning of the installation directories:
   --infodir=DIR           info documentation [DATAROOTDIR/info]
   --localedir=DIR         locale-dependent data [DATAROOTDIR/locale]
   --mandir=DIR            man documentation [DATAROOTDIR/man]
-  --docdir=DIR            documentation root [DATAROOTDIR/doc/xapian-core]
+  --docdir=DIR            documentation root [DATAROOTDIR/doc/xapian-core-scws]
   --htmldir=DIR           html documentation [DOCDIR]
   --dvidir=DIR            dvi documentation [DOCDIR]
   --pdfdir=DIR            pdf documentation [DOCDIR]
@@ -1432,7 +1433,7 @@ fi
 
 if test -n "$ac_init_help"; then
   case $ac_init_help in
-     short | recursive ) echo "Configuration of xapian-core 1.2.18:";;
+     short | recursive ) echo "Configuration of xapian-core-scws 1.2.18:";;
    esac
   cat <<\_ACEOF
 
@@ -1476,6 +1477,8 @@ Optional Packages:
   --with-gnu-ld           assume the C compiler uses GNU ld [default=no]
   --with-sysroot=DIR Search for dependent libraries within DIR
                         (or the compiler's sysroot if not specified).
+  --with-scws[=DIR]       use scws as default tokenizer, DIR is the install
+                          PREFIX of scws
 
 Some influential environment variables:
   CC          C compiler command
@@ -1559,7 +1562,7 @@ fi
 test -n "$ac_init_help" && exit $ac_status
 if $ac_init_version; then
   cat <<\_ACEOF
-xapian-core configure 1.2.18
+xapian-core-scws configure 1.2.18
 generated by GNU Autoconf 2.68
 
 Copyright (C) 2010 Free Software Foundation, Inc.
@@ -2330,7 +2333,7 @@ cat >config.log <<_ACEOF
 This file contains any messages produced by compilers while
 running configure, to aid debugging if configure makes a mistake.
 
-It was created by xapian-core $as_me 1.2.18, which was
+It was created by xapian-core-scws $as_me 1.2.18, which was
 generated by GNU Autoconf 2.68.  Invocation command line was
 
   $ $0 $@
@@ -3183,7 +3186,7 @@ fi
 
 
 # Define the identity of the package.
- PACKAGE='xapian-core'
+ PACKAGE='xapian-core-scws'
  VERSION='1.2.18'
 
 
@@ -18438,6 +18441,115 @@ $as_echo "#define XAPIAN_DEBUG_LOG /**/" >>confdefs.h
 
 fi
 
+SCWS_DIR=""
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for scws" >&5
+$as_echo_n "checking for scws... " >&6; }
+
+# Check whether --with-scws was given.
+if test "${with_scws+set}" = set; then :
+  withval=$with_scws;
+else
+   with_scws=no
+
+fi
+
+
+if test "$with_scws" = "no"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+else
+  # Check header file
+  if test "$with_scws" = "yes"; then
+    searchdirs="/usr /usr/local /usr/local/scws /opt/local"
+    for tmpdir in $searchdirs ; do
+      if test -f $tmpdir/include/scws/scws.h ; then
+        SCWS_DIR=$tmpdir
+        break
+      fi
+    done
+    if test "$SCWS_DIR" = ""; then
+      { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+      as_fn_error $? "scws not found on default search directories, specify DIR plz..." "$LINENO" 5
+    fi
+  elif test -f $withval/include/scws/scws.h ; then
+    SCWS_DIR=$withval
+  else
+    { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+    as_fn_error $? "Invalid scws directory, unable to find the scws.h under $withval/include/scws" "$LINENO" 5
+  fi
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes: $SCWS_DIR" >&5
+$as_echo "yes: $SCWS_DIR" >&6; }
+
+  # Etc directory
+  if test "$SCWS_DIR" = "/usr"; then
+    SCWS_ETCDIR="/etc"
+  else
+    SCWS_ETCDIR="$SCWS_DIR/etc"
+  fi
+
+  # Check scws library
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for scws_new in -lscws" >&5
+$as_echo_n "checking for scws_new in -lscws... " >&6; }
+if ${ac_cv_lib_scws_scws_new+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lscws
+    -L$SCWS_DIR/lib
+   $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char scws_new ();
+int
+main ()
+{
+return scws_new ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_cxx_try_link "$LINENO"; then :
+  ac_cv_lib_scws_scws_new=yes
+else
+  ac_cv_lib_scws_scws_new=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_scws_scws_new" >&5
+$as_echo "$ac_cv_lib_scws_scws_new" >&6; }
+if test "x$ac_cv_lib_scws_scws_new" = xyes; then :
+
+    LIBS="$LIBS -L$SCWS_DIR/lib -lscws"
+    XAPIAN_LDFLAGS="$XAPIAN_LDFLAGS -L$SCWS_DIR/lib -lscws"
+    CPPFLAGS="$CPPFLAGS -I$SCWS_DIR/include"
+
+$as_echo "#define HAVE_SCWS 1" >>confdefs.h
+
+
+cat >>confdefs.h <<_ACEOF
+#define SCWS_ETCDIR "$SCWS_ETCDIR"
+_ACEOF
+
+
+else
+
+    as_fn_error $? "scws_new() NOT found in libscws, please check it first." "$LINENO" 5
+
+fi
+
+fi
+
 
 dash_d_visibility=
 if test yes = "$GXX"; then
@@ -19402,7 +19514,7 @@ cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
 # report actual input values of CONFIG_FILES etc. instead of their
 # values after options handling.
 ac_log="
-This file was extended by xapian-core $as_me 1.2.18, which was
+This file was extended by xapian-core-scws $as_me 1.2.18, which was
 generated by GNU Autoconf 2.68.  Invocation command line was
 
   CONFIG_FILES    = $CONFIG_FILES
@@ -19468,7 +19580,7 @@ _ACEOF
 cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
 ac_cs_config="`$as_echo "$ac_configure_args" | sed 's/^ //; s/[\\""\`\$]/\\\\&/g'`"
 ac_cs_version="\\
-xapian-core config.status 1.2.18
+xapian-core-scws config.status 1.2.18
 configured by $0, generated by GNU Autoconf 2.68,
   with options \\"\$ac_cs_config\\"
 
diff --git a/xapian-core-1.2.18/configure.ac b/xapian-core-1.2.18/configure.ac
index 16ed452..fb4cac3 100644
--- a/xapian-core-1.2.18/configure.ac
+++ b/xapian-core-1.2.18/configure.ac
@@ -2,7 +2,7 @@ dnl Process this file with autoconf to produce a configure script.
 
 dnl NB When updating the version for a release, update LIBRARY_VERSION_INFO
 dnl below too.
-AC_INIT([xapian-core], [1.2.18], [http://xapian.org/bugs])
+AC_INIT([xapian-core-scws], [1.2.18], [http://xapian.org/bugs])
 dnl See HACKING document for details of the reasons for required versions.
 AC_PREREQ([2.64])
 dnl Extract from the libtool info manual:
@@ -1087,6 +1087,62 @@ if test yes = "$enable_log"; then
     [Define if you want a log of methods called and other debug messages])
 fi
 
+dnl **********************
+dnl * Check scws library *
+dnl **********************
+dnl hightman.20110411: See if we want to use scws as default tokenizer
+SCWS_DIR=""
+AC_MSG_CHECKING(for scws)
+AC_ARG_WITH(scws,
+  [AS_HELP_STRING([--with-scws@<:@=DIR@:>@], [use scws as default tokenizer, DIR is the install PREFIX of scws])],
+  [ ],[ with_scws=no ]
+)
+
+if test "$with_scws" = "no"; then
+  AC_MSG_RESULT(no)
+else
+  # Check header file
+  if test "$with_scws" = "yes"; then
+    searchdirs="/usr /usr/local /usr/local/scws /opt/local"
+    for tmpdir in $searchdirs ; do
+      if test -f $tmpdir/include/scws/scws.h ; then
+        SCWS_DIR=$tmpdir
+        break
+      fi
+    done
+    if test "$SCWS_DIR" = ""; then
+      AC_MSG_RESULT(no)
+      AC_MSG_ERROR([scws not found on default search directories, specify DIR plz...])
+    fi
+  elif test -f $withval/include/scws/scws.h ; then
+    SCWS_DIR=$withval
+  else
+    AC_MSG_RESULT(no)
+    AC_MSG_ERROR([Invalid scws directory, unable to find the scws.h under $withval/include/scws])
+  fi
+  AC_MSG_RESULT([yes: $SCWS_DIR])
+
+  # Etc directory
+  if test "$SCWS_DIR" = "/usr"; then
+    SCWS_ETCDIR="/etc"
+  else
+    SCWS_ETCDIR="$SCWS_DIR/etc"
+  fi
+
+  # Check scws library
+  AC_CHECK_LIB(scws, scws_new, [
+    LIBS="$LIBS -L$SCWS_DIR/lib -lscws"
+    XAPIAN_LDFLAGS="$XAPIAN_LDFLAGS -L$SCWS_DIR/lib -lscws"
+    CPPFLAGS="$CPPFLAGS -I$SCWS_DIR/include"
+    AC_DEFINE(HAVE_SCWS, 1, [Define to 1 if you want to use scws as default tokenizer])
+    AC_DEFINE_UNQUOTED(SCWS_ETCDIR, "$SCWS_ETCDIR", [Resources directory of scws to load dictionary and rules])
+  ],[
+    AC_MSG_ERROR([scws_new() NOT found in libscws, please check it first.])
+  ],[
+    -L$SCWS_DIR/lib
+  ])
+fi
+
 dnl ******************************
 dnl * Set special compiler flags *
 dnl ******************************
diff --git a/xapian-core-1.2.18/include/xapian/queryparser.h b/xapian-core-1.2.18/include/xapian/queryparser.h
index 8aeaf6c..66acb3d 100644
--- a/xapian-core-1.2.18/include/xapian/queryparser.h
+++ b/xapian-core-1.2.18/include/xapian/queryparser.h
@@ -559,6 +559,15 @@ class XAPIAN_VISIBILITY_DEFAULT QueryParser {
      */
     void set_max_wildcard_expansion(Xapian::termcount limit);
 
+#if 1   /* HAVE_SCWS */
+    /** hightman.20070706: Specify the dict and rules file for scws, only used when HAVE_SCWS.
+     *  @param fpath    path for dict file and rule file (char *)
+     *  @param xmem whether to load whold dict into memory(default to false)
+     *  @param multi    multiset (int 0~15)
+     */
+    void load_libscws(const char *fpath, bool xmem = false, int multi = 0);
+#endif
+
     /** Parse a query.
      *
      *  @param query_string  A free-text query as entered by a user
diff --git a/xapian-core-1.2.18/include/xapian/termgenerator.h b/xapian-core-1.2.18/include/xapian/termgenerator.h
index db42350..e5bb7cd 100644
--- a/xapian-core-1.2.18/include/xapian/termgenerator.h
+++ b/xapian-core-1.2.18/include/xapian/termgenerator.h
@@ -82,6 +82,11 @@ class XAPIAN_VISIBILITY_DEFAULT TermGenerator {
     /// Set the database to index spelling data to.
     void set_database(const Xapian::WritableDatabase &db);
 
+#if 1   /* HAVE_SCWS */
+    /// hightman.20070706: Specify the dict and rules file for scws, only used when HAVE_SCWS.
+    void load_libscws(const char *fpath, bool xmem = false, int multi = 0);
+#endif
+
     /// Flags to OR together and pass to TermGenerator::set_flags().
     enum flags {
 	/// Index data required for spelling correction.
diff --git a/xapian-core-1.2.18/queryparser/queryparser.cc b/xapian-core-1.2.18/queryparser/queryparser.cc
index 33e47dc..29a2d61 100644
--- a/xapian-core-1.2.18/queryparser/queryparser.cc
+++ b/xapian-core-1.2.18/queryparser/queryparser.cc
@@ -110,6 +110,17 @@ QueryParser::set_max_wildcard_expansion(Xapian::termcount max)
     internal->max_wildcard_expansion = max;
 }
 
+#if 1	/* HAVE_SCWS */
+/// hightman.20070701: load the specified dict file for scws
+void
+QueryParser::load_libscws(const char *fpath, bool xmem, int multi)
+{
+#ifdef HAVE_SCWS
+    internal->load_libscws(fpath, xmem, multi);
+#endif
+}
+#endif
+
 Query
 QueryParser::parse_query(const string &query_string, unsigned flags,
 			 const string &default_prefix)
diff --git a/xapian-core-1.2.18/queryparser/queryparser_internal.cc b/xapian-core-1.2.18/queryparser/queryparser_internal.cc
index b012619..45633c6 100644
--- a/xapian-core-1.2.18/queryparser/queryparser_internal.cc
+++ b/xapian-core-1.2.18/queryparser/queryparser_internal.cc
@@ -160,6 +160,9 @@ class Term {
     string unstemmed;
     QueryParser::stem_strategy stem;
     termpos pos;
+#ifdef HAVE_SCWS
+    vector<string> multi;
+#endif
 
     Term(const string &name_, termpos pos_) : name(name_), stem(QueryParser::STEM_NONE), pos(pos_) { }
     Term(const string &name_) : name(name_), stem(QueryParser::STEM_NONE), pos(0) { }
@@ -313,10 +316,15 @@ Term::get_query_with_synonyms() const
     for (piter = prefixes.begin(); piter != prefixes.end(); ++piter) {
 	// First try the unstemmed term:
 	string term;
+	/* hightman.111231: Synonym optimization　*/
+#ifdef HAVE_SCWS
+	termpos mpos = pos + 77;
+#else
 	if (!piter->empty()) {
 	    term += *piter;
 	    if (prefix_needs_colon(*piter, name[0])) term += ':';
 	}
+#endif
 	term += name;
 
 	Xapian::Database db = state->get_database();
@@ -325,16 +333,28 @@ Term::get_query_with_synonyms() const
 	if (syn == end && stem != QueryParser::STEM_NONE) {
 	    // If that has no synonyms, try the stemmed form:
 	    term = 'Z';
+#ifndef HAVE_SCWS
 	    if (!piter->empty()) {
 		term += *piter;
 		if (prefix_needs_colon(*piter, name[0])) term += ':';
 	    }
+#endif
 	    term += state->stem_term(name);
 	    syn = db.synonyms_begin(term);
 	    end = db.synonyms_end(term);
 	}
 	while (syn != end) {
+#ifdef HAVE_SCWS
+	    string sterm = *syn;
+	    if (!piter->empty()) {
+		if (sterm[0] == 'Z') sterm = "Z" + *piter + sterm.substr(1);
+		else sterm = *piter + sterm;
+	    }
+
+	    q = Query(Query::OP_SYNONYM, q, Query(sterm, 1, mpos++));
+#else
 	    q = Query(Query::OP_SYNONYM, q, Query(*syn, 1, pos));
+#endif
 	    ++syn;
 	}
     }
@@ -452,6 +472,58 @@ Term::as_cjk_query() const
     vector<Query> prefix_cjk;
     const list<string> & prefixes = prefix_info->prefixes;
     list<string>::const_iterator piter;
+/* hightman.20111223: used CJKTERM for multi segment */
+#ifdef HAVE_SCWS
+    for (piter = prefixes.begin(); piter != prefixes.end(); ++piter) {
+	Query org = Query(*piter + name, 1, pos); 
+	termpos mpos = pos + 88;
+
+	/* hightman.20120104: get synonyms */
+	if (state->flags & QueryParser::FLAG_AUTO_SYNONYMS) {
+	    Xapian::Database db = state->get_database();
+	    Xapian::TermIterator syn = db.synonyms_begin(name);
+	    Xapian::TermIterator end = db.synonyms_end(name);
+	    while (syn != end) {
+		org = Query(Query::OP_SYNONYM, org, Query(*piter + *syn, 1, mpos++));
+		++syn;
+	    }
+	}
+
+        if (state->flags & QueryParser::FLAG_PARTIAL) {
+            Xapian::Database db = state->get_database();
+            Xapian::TermIterator tem = db.allterms_begin(*piter + name);
+            Xapian::TermIterator end = db.allterms_end(*piter + name);
+            while (tem != end) {
+                //org = Query(Query::OP_SYNONYM, org, Query(*piter + *tem, 1, mpos++));
+		if(*piter + name != *tem)
+                org = Query(Query::OP_SYNONYM, org, Query(*tem, 1, mpos++));
+                ++tem;
+            }
+        }
+/*	
+       else if (state->flags & QueryParser::FLAG_PARTIAL) {
+            Xapian::Database db = state->get_database();
+            Xapian::TermIterator syn = db.synonyms_begin(name);
+            Xapian::TermIterator end = db.synonyms_end(name);
+            while (syn != end) {
+                org = Query(Query::OP_SYNONYM, org, Query(*piter + *syn, 1, mpos++));
+                ++syn;
+            }
+        }
+*/
+	if (!multi.empty()) {
+	    vector<string>::const_iterator mi;
+	    vector<Query> multi_cjk;
+	    for (mi = multi.begin(); mi != multi.end(); ++mi) {
+		// hightman: force to sort behind for get_terms()
+		multi_cjk.push_back(Query(*piter + *mi, 1, mpos++));
+	    }
+	    Query syn = Query(state->default_op(), multi_cjk.begin(), multi_cjk.end());
+	    org = Query(Query::OP_SYNONYM, org, syn);
+	}
+	prefix_cjk.push_back(org);
+    }
+#else
     for (CJKTokenIterator tk(name); tk != CJKTokenIterator(); ++tk) {
 	for (piter = prefixes.begin(); piter != prefixes.end(); ++piter) {
 	    string cjk = *piter;
@@ -459,6 +531,7 @@ Term::as_cjk_query() const
 	    prefix_cjk.push_back(Query(cjk, 1, pos));
 	}
     }
+#endif	/* HAVE_SCWS */
     Query * q = new Query(Query::OP_AND, prefix_cjk.begin(), prefix_cjk.end());
     delete this;
     return q;
@@ -572,12 +645,78 @@ QueryParser::Internal::add_prefix(const string &field, const string &prefix,
    }
 }
 
+/// hightman.20110701: load libscws
+#ifdef HAVE_SCWS
+QueryParser::Internal::~Internal()
+{
+    if (rptr != NULL) {
+	scws_free_result(rptr);
+	rptr = NULL;
+    }    
+    if (scws != NULL) {
+	scws_free(scws);
+	scws = NULL;
+    }    
+}
+
+void
+QueryParser::Internal::load_libscws(const char *fpath, bool xmem, int multi)
+{
+    if (scws == NULL) {
+	string temp;
+
+	scws = scws_new();
+	scws_set_charset(scws, "utf8");
+	scws_set_ignore(scws, SCWS_NA);
+	scws_set_duality(scws, SCWS_YEA);
+
+	temp = string(fpath ? fpath : SCWS_ETCDIR) + string("/rules.utf8.ini");
+	scws_set_rule(scws, temp.data());
+	temp = string(fpath ? fpath : SCWS_ETCDIR) + string("/dict.utf8.xdb");
+	scws_set_dict(scws, temp.data(), xmem == true ? SCWS_XDICT_MEM : SCWS_XDICT_XDB);
+	/* hightman.20111209: custom dict support */
+	temp = string(fpath ? fpath : SCWS_ETCDIR) + string("/dict_user.txt");
+	scws_add_dict(scws, temp.data(), SCWS_XDICT_TXT);
+    }
+    if (multi >= 0 && multi < 0x10)
+	scws_set_multi(scws, (multi<<12));
+}
+#endif	/* HAVE_SCWS */
+
 string
 QueryParser::Internal::parse_term(Utf8Iterator &it, const Utf8Iterator &end,
 				  bool cjk_ngram, bool & is_cjk_term,
 				  bool &was_acronym)
 {
     string term;
+#ifdef HAVE_SCWS
+    int off = it.raw() - qptr;
+    while (rcur && (off > rcur->off)) {
+	rcur = rcur->next;
+    }
+    was_acronym = false;
+    if (rcur == NULL) { 
+	it = end;
+	term.resize(0);
+    } else {
+	// sometimes, auto_duality + word-end single word char will be repeated
+	// 说明几句 => 说明/几/几句
+	if (rcur->next && rcur->next->off == rcur->off && rcur->next->len > rcur->len)
+	    rcur = rcur->next;
+
+	term.append(qptr + rcur->off, rcur->len);
+	was_acronym = (rcur->attr[0] == 'n' && rcur->attr[1] == 'z') ? true : false;
+	is_cjk_term = CJK::codepoint_is_cjk(*it);
+	last_off = off = rcur->off + rcur->len;
+	rcur = rcur->next;
+
+	// sometimes, auto duality or multisegment
+	// 几句说搞笑 => 几句/句说/搞笑
+	if (rcur && off > rcur->off && (rcur->off + rcur->len) > off)
+	    off = rcur->off;
+	while ((it.raw() - qptr) < off) it++;
+    }
+#else	/* HAVE_SCWS */
     // Look for initials separated by '.' (e.g. P.T.O., U.N.C.L.E).
     // Don't worry if there's a trailing '.' or not.
     if (U_isupper(*it)) {
@@ -662,6 +801,7 @@ QueryParser::Internal::parse_term(Utf8Iterator &it, const Utf8Iterator &end,
 	    }
 	}
     }
+#endif	/* HAVE_SCWS */
     return term;
 }
 
@@ -713,6 +853,32 @@ QueryParser::Internal::parse_query(const string &qs, unsigned flags,
 
     ParserHandler pParser(ParseAlloc());
 
+#ifdef HAVE_SCWS
+    /// Pre segmentation use scws
+    scws_res_t res;
+
+    if (!scws) { 
+	load_libscws(NULL, false, 0);
+    }
+    if (rptr != NULL) {
+	scws_free_result(rptr);
+	rptr = NULL;
+    }
+    qptr = qs.data();
+    scws_send_text(scws, qptr, qs.size());
+    while ((res = scws_get_result(scws)) != NULL) {
+	if (rptr == NULL) { 
+	    rcur = rptr = res;
+        } else { 
+	    rcur->next = res;
+        }
+	while (rcur->next != NULL) { 
+	    rcur = rcur->next;
+	}
+    }
+    rcur = rptr;
+#endif	/* HAVE_SCWS */
+
     unsigned newprev = ' ';
 main_lex_loop:
     enum {
@@ -1110,6 +1276,11 @@ phrased_term:
 		if (!stemmer.internal.get()) {
 		    // No stemmer is set.
 		    stem_term = STEM_NONE;
+#ifdef HAVE_SCWS
+		} else if (is_cjk_term) {
+		    // Don't stem CJK terms.
+		    stem_term = STEM_NONE;
+#endif
 		} else if (stem_term == STEM_SOME) {
 		    if (!should_stem(unstemmed_term) ||
 			(it != end && is_stem_preventer(*it))) {
@@ -1123,6 +1294,17 @@ phrased_term:
 				       unstemmed_term, stem_term, term_pos++);
 
 	    if (is_cjk_term) {
+#ifdef HAVE_SCWS
+		/* multi scws handler */
+		term_obj->multi.clear();
+		while (rcur && (rcur->off + rcur->len) <= last_off) {
+			if (rcur->len > 3)
+				term_obj->multi.push_back(string(qptr + rcur->off, rcur->len));
+		    rcur = rcur->next;
+		}
+		if (mode == IN_GROUP || mode == IN_GROUP2)
+		    mode = DEFAULT;
+#endif
 		Parse(pParser, CJKTERM, term_obj, &state);
 		if (it == end) break;
 		continue;
@@ -1253,6 +1435,13 @@ phrased_term:
 	}
     }
 done:
+ #ifdef HAVE_SCWS
+    /// Free all segmented terms/words
+    if (rptr != NULL) {
+	scws_free_result(rptr);
+	rptr = NULL;
+    }
+#endif
     if (!state.error) {
 	// Implicitly close any unclosed quotes.
 	if (mode == IN_QUOTES || mode == IN_PREFIXED_QUOTES)
@@ -1451,9 +1640,20 @@ reprocess:
 
 	    // Use the position of the first term for the synonyms.
 	    Xapian::termpos pos = (*begin)->pos;
+#ifdef HAVE_SCWS
+	    string prefix;
+	    const list<string> & prefixes = (*begin)->prefix_info->prefixes;
+	    if (prefixes.begin() != prefixes.end())
+		prefix = *(prefixes.begin());
+	    pos += 66;
+#endif
 	    begin = i;
 	    while (syn != end) {
+#ifdef HAVE_SCWS
+		subqs2.push_back(Query(prefix + *syn, 1, pos++));
+#else
 		subqs2.push_back(Query(*syn, 1, pos));
+#endif
 		++syn;
 	    }
 	    Query q_synonym_terms(Query::OP_SYNONYM, subqs2.begin(), subqs2.end());
@@ -1618,6 +1818,11 @@ class Terms {
 void
 Term::as_positional_cjk_term(Terms * terms) const
 {
+#ifdef HAVE_SCWS
+    // Add SCWS term only
+    Term * c = new Term(state, name, prefix_info, unstemmed, stem, pos);
+    terms->add_positional_term(c);
+#else
     // Add each individual CJK character to the phrase.
     string t;
     for (Utf8Iterator it(name); it != Utf8Iterator(); ++it) {
@@ -1626,6 +1831,7 @@ Term::as_positional_cjk_term(Terms * terms) const
 	terms->add_positional_term(c);
 	t.resize(0);
     }
+#endif	/* HAVE_SCWS */
 
     // FIXME: we want to add the n-grams as filters too for efficiency.
 
diff --git a/xapian-core-1.2.18/queryparser/queryparser_internal.h b/xapian-core-1.2.18/queryparser/queryparser_internal.h
index c71f7df..3ade7b7 100644
--- a/xapian-core-1.2.18/queryparser/queryparser_internal.h
+++ b/xapian-core-1.2.18/queryparser/queryparser_internal.h
@@ -29,6 +29,11 @@
 #include <xapian/queryparser.h>
 #include <xapian/stem.h>
 
+/// hightman.20070701: use scws as default tokneizer
+#ifdef HAVE_SCWS
+#include <scws/scws.h>
+#endif
+
 #include <list>
 #include <map>
 
@@ -63,6 +68,12 @@ class QueryParser::Internal : public Xapian::Internal::RefCntBase {
     Stem stemmer;
     stem_strategy stem_action;
     const Stopper * stopper;
+#ifdef HAVE_SCWS
+    scws_t scws;
+    scws_res_t rptr, rcur;
+    const char *qptr;
+    int last_off;
+#endif
     Query::op default_op;
     const char * errmsg;
     Database db;
@@ -88,8 +99,16 @@ class QueryParser::Internal : public Xapian::Internal::RefCntBase {
 
   public:
     Internal() : stem_action(STEM_NONE), stopper(NULL),
+#ifdef HAVE_SCWS
+	scws(NULL), rptr(NULL), rcur(NULL),
+#endif
 	default_op(Query::OP_OR), errmsg(NULL), max_wildcard_expansion(0) { }
+#ifdef HAVE_SCWS
+    ~Internal();
+    void load_libscws(const char *fpath, bool xmem, int multi);
+#endif
     Query parse_query(const string & query_string, unsigned int flags, const string & default_prefix);
+
 };
 
 }
diff --git a/xapian-core-1.2.18/queryparser/termgenerator.cc b/xapian-core-1.2.18/queryparser/termgenerator.cc
index 3b2dc1a..ad60020 100644
--- a/xapian-core-1.2.18/queryparser/termgenerator.cc
+++ b/xapian-core-1.2.18/queryparser/termgenerator.cc
@@ -74,6 +74,17 @@ TermGenerator::set_database(const Xapian::WritableDatabase &db)
     internal->db = db;
 }
 
+#if 1	/* HAVE_SCWS */
+/// hightman.20070701: load the specified dict file for scws
+void
+TermGenerator::load_libscws(const char *fpath, bool xmem, int multi)
+{
+#ifdef HAVE_SCWS
+    internal->load_libscws(fpath, xmem, multi);
+#endif
+}
+#endif
+
 TermGenerator::flags
 TermGenerator::set_flags(flags toggle, flags mask)
 {
diff --git a/xapian-core-1.2.18/queryparser/termgenerator_internal.cc b/xapian-core-1.2.18/queryparser/termgenerator_internal.cc
index 59c9ff9..a9b05cc 100644
--- a/xapian-core-1.2.18/queryparser/termgenerator_internal.cc
+++ b/xapian-core-1.2.18/queryparser/termgenerator_internal.cc
@@ -117,6 +117,40 @@ inline unsigned check_suffix(unsigned ch) {
 #define STOPWORDS_IGNORE 1
 #define STOPWORDS_INDEX_UNSTEMMED_ONLY 2
 
+/// hightman.20070701: load libscws
+#ifdef HAVE_SCWS
+TermGenerator::Internal::~Internal()
+{
+    if (scws != NULL) {
+	scws_free(scws);
+	scws = NULL;
+    }
+}
+
+void 
+TermGenerator::Internal::load_libscws(const char *fpath, bool xmem, int multi)
+{
+    if (scws == NULL) {
+	string temp;
+
+	scws = scws_new();
+	scws_set_charset(scws, "utf8");
+	scws_set_ignore(scws, SCWS_NA);
+	scws_set_duality(scws, SCWS_YEA);
+
+	temp = string(fpath ? fpath : SCWS_ETCDIR) + string("/rules.utf8.ini");
+	scws_set_rule(scws, temp.data());
+	temp = string(fpath ? fpath : SCWS_ETCDIR) + string("/dict.utf8.xdb");
+	scws_set_dict(scws, temp.data(), xmem == true ? SCWS_XDICT_MEM : SCWS_XDICT_XDB);
+	/* hightman.20111209: custom dict support */
+	temp = string(fpath ? fpath : SCWS_ETCDIR) + string("/dict_user.txt");
+	scws_add_dict(scws, temp.data(), SCWS_XDICT_TXT);
+    }
+    if (multi >= 0 && multi < 0x10) 
+	scws_set_multi(scws, (multi<<12));
+}
+#endif
+
 void
 TermGenerator::Internal::index_text(Utf8Iterator itor, termcount wdf_inc,
 				    const string & prefix, bool with_positions)
@@ -127,6 +161,37 @@ TermGenerator::Internal::index_text(Utf8Iterator itor, termcount wdf_inc,
 
     if (!stopper) stop_mode = STOPWORDS_NONE;
 
+#ifdef HAVE_SCWS
+    int last_endpos = 0, last_off = 0;
+    scws_res_t res, cur;
+    Utf8Iterator iterm;
+    const char *text = itor.raw();
+
+    if (!scws) load_libscws(NULL, false, 0);
+    scws_send_text(scws, text, itor.left());
+    while ((res = cur = scws_get_result(scws)) != NULL) { while (cur != NULL) {
+	string term;
+
+	iterm.assign(text + cur->off, cur->len);
+	if (!Unicode::is_wordchar(*iterm)) {
+	    cur = cur->next;
+	    continue;
+	}
+	term = Unicode::tolower(string(text + cur->off, cur->len));
+	if (with_positions) {
+	    /// for part word(short, duality)
+	    if ((cur->off + cur->len) <= last_endpos)
+		--termpos;
+	    else {
+		/// for dualities' first single word
+		if (cur->off == last_off)
+		    --termpos;
+		last_endpos = cur->off + cur->len;
+	    }
+	}
+	last_off = cur->off;
+	cur = cur->next;
+#else
     while (true) {
 	// Advance to the start of the next term.
 	unsigned ch;
@@ -265,6 +330,7 @@ TermGenerator::Internal::index_text(Utf8Iterator itor, termcount wdf_inc,
 	}
 
 endofterm:
+#endif	/* HAVE_SCWS */
 	if (term.size() > max_word_length) continue;
 
 	if (stop_mode == STOPWORDS_IGNORE && (*stopper)(term)) continue;
@@ -277,6 +343,10 @@ endofterm:
 		doc.add_term(prefix + term, wdf_inc);
 	    }
 	}
+#ifdef HAVE_SCWS
+	/// hightman: Term start with CJK character needn't spell & stem
+	if (CJK::codepoint_is_cjk(*iterm)) continue;
+#endif
 	if ((flags & FLAG_SPELLING) && prefix.empty()) db.add_spelling(term);
 
 	if (strategy == TermGenerator::STEM_NONE ||
@@ -305,6 +375,9 @@ endofterm:
 	    doc.add_term(stem, wdf_inc);
 	}
     }
+#ifdef HAVE_SCWS
+    scws_free_result(res); }
+#endif
 }
 
 }
diff --git a/xapian-core-1.2.18/queryparser/termgenerator_internal.h b/xapian-core-1.2.18/queryparser/termgenerator_internal.h
index f500e4e..b3f5134 100644
--- a/xapian-core-1.2.18/queryparser/termgenerator_internal.h
+++ b/xapian-core-1.2.18/queryparser/termgenerator_internal.h
@@ -26,6 +26,10 @@
 #include <xapian/document.h>
 #include <xapian/termgenerator.h>
 #include <xapian/stem.h>
+/// hightman.20070701: use scws as default tokneizer
+#ifdef HAVE_SCWS
+#include <scws/scws.h>
+#endif
 
 namespace Xapian {
 
@@ -38,13 +42,23 @@ class TermGenerator::Internal : public Xapian::Internal::RefCntBase {
     const Stopper * stopper;
     Document doc;
     termcount termpos;
+#ifdef HAVE_SCWS
+    scws_t scws;
+#endif
     TermGenerator::flags flags;
     unsigned max_word_length;
     WritableDatabase db;
 
   public:
     Internal() : strategy(STEM_SOME), stopper(NULL), termpos(0),
+#ifdef HAVE_SCWS
+	scws(NULL),
+#endif
 	flags(TermGenerator::flags(0)), max_word_length(64) { }
+#ifdef HAVE_SCWS
+    ~Internal();
+    void load_libscws(const char *fpath, bool xmem, int multi);
+#endif
     void index_text(Utf8Iterator itor,
 		    termcount weight,
 		    const std::string & prefix,
